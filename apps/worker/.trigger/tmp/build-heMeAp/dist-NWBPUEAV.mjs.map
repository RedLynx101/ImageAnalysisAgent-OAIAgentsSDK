{
  "version": 3,
  "sources": ["../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/parser.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/helpers.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/error.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/constants.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/fetch.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/client.ts", "../../../../../../root/.npm/_npx/7372b51fc06f79a7/node_modules/@electric-sql/client/src/shape.ts"],
  "sourcesContent": ["import { ColumnInfo, GetExtensions, Message, Row, Schema, Value } from './types'\n\ntype NullToken = null | `NULL`\ntype Token = Exclude<string, NullToken>\ntype NullableToken = Token | NullToken\nexport type ParseFunction<Extensions = never> = (\n  value: Token,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\ntype NullableParseFunction<Extensions = never> = (\n  value: NullableToken,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\n/**\n * @typeParam Extensions - Additional types that can be parsed by this parser beyond the standard SQL types.\n *                         Defaults to no additional types.\n */\nexport type Parser<Extensions = never> = {\n  [key: string]: ParseFunction<Extensions>\n}\n\nconst parseNumber = (value: string) => Number(value)\nconst parseBool = (value: string) => value === `true` || value === `t`\nconst parseBigInt = (value: string) => BigInt(value)\nconst parseJson = (value: string) => JSON.parse(value)\nconst identityParser: ParseFunction = (v: string) => v\n\nexport const defaultParser: Parser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson,\n}\n\n// Taken from: https://github.com/electric-sql/pglite/blob/main/packages/pglite/src/types.ts#L233-L279\nexport function pgArrayParser<Extensions>(\n  value: Token,\n  parser?: ParseFunction<Extensions>\n): Value<Extensions> {\n  let i = 0\n  let char = null\n  let str = ``\n  let quoted = false\n  let last = 0\n  let p: string | undefined = undefined\n\n  function loop(x: string): Array<Value<Extensions>> {\n    const xs = []\n    for (; i < x.length; i++) {\n      char = x[i]\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i]\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str)\n          str = ``\n          quoted = x[i + 1] === `\"`\n          last = i + 2\n        } else {\n          str += char\n        }\n      } else if (char === `\"`) {\n        quoted = true\n      } else if (char === `{`) {\n        last = ++i\n        xs.push(loop(x))\n      } else if (char === `}`) {\n        quoted = false\n        last < i &&\n          xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n        break\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n      }\n      p = char\n    }\n    last < i &&\n      xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1))\n    return xs\n  }\n\n  return loop(value)[0]\n}\n\nexport class MessageParser<T extends Row<unknown>> {\n  private parser: Parser<GetExtensions<T>>\n  constructor(parser?: Parser<GetExtensions<T>>) {\n    // Merge the provided parser with the default parser\n    // to use the provided parser whenever defined\n    // and otherwise fall back to the default parser\n    this.parser = { ...defaultParser, ...parser }\n  }\n\n  parse(messages: string, schema: Schema): Message<T>[] {\n    return JSON.parse(messages, (key, value) => {\n      // typeof value === `object` && value !== null\n      // is needed because there could be a column named `value`\n      // and the value associated to that column will be a string or null.\n      // But `typeof null === 'object'` so we need to make an explicit check.\n      if (key === `value` && typeof value === `object` && value !== null) {\n        // Parse the row values\n        const row = value as Record<string, Value<GetExtensions<T>>>\n        Object.keys(row).forEach((key) => {\n          row[key] = this.parseRow(key, row[key] as NullableToken, schema)\n        })\n      }\n      return value\n    }) as Message<T>[]\n  }\n\n  // Parses the message values using the provided parser based on the schema information\n  private parseRow(\n    key: string,\n    value: NullableToken,\n    schema: Schema\n  ): Value<GetExtensions<T>> {\n    const columnInfo = schema[key]\n    if (!columnInfo) {\n      // We don't have information about the value\n      // so we just return it\n      return value\n    }\n\n    // Copy the object but don't include `dimensions` and `type`\n    const { type: typ, dims: dimensions, ...additionalInfo } = columnInfo\n\n    // Pick the right parser for the type\n    // and support parsing null values if needed\n    // if no parser is provided for the given type, just return the value as is\n    const typeParser = this.parser[typ] ?? identityParser\n    const parser = makeNullableParser(typeParser, columnInfo, key)\n\n    if (dimensions && dimensions > 0) {\n      // It's an array\n      const nullablePgArrayParser = makeNullableParser(\n        (value, _) => pgArrayParser(value, parser),\n        columnInfo,\n        key\n      )\n      return nullablePgArrayParser(value)\n    }\n\n    return parser(value, additionalInfo)\n  }\n}\n\nfunction makeNullableParser<Extensions>(\n  parser: ParseFunction<Extensions>,\n  columnInfo: ColumnInfo,\n  columnName?: string\n): NullableParseFunction<Extensions> {\n  const isNullable = !(columnInfo.not_null ?? false)\n  // The sync service contains `null` value for a column whose value is NULL\n  // but if the column value is an array that contains a NULL value\n  // then it will be included in the array string as `NULL`, e.g.: `\"{1,NULL,3}\"`\n  return (value: NullableToken) => {\n    if (isPgNull(value)) {\n      if (!isNullable) {\n        throw new Error(`Column ${columnName ?? `unknown`} is not nullable`)\n      }\n      return null\n    }\n    return parser(value, columnInfo)\n  }\n}\n\nfunction isPgNull(value: NullableToken): value is NullToken {\n  return value === null || value === `NULL`\n}\n", "import { ChangeMessage, ControlMessage, Message, Row } from './types'\n\n/**\n * Type guard for checking {@link Message} is {@link ChangeMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ChangeMessage}\n *\n * @example\n * ```ts\n * if (isChangeMessage(message)) {\n *   const msgChng: ChangeMessage = message // Ok\n *   const msgCtrl: ControlMessage = message // Err, type mismatch\n * }\n * ```\n */\nexport function isChangeMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ChangeMessage<T> {\n  return `key` in message\n}\n\n/**\n * Type guard for checking {@link Message} is {@link ControlMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ControlMessage}\n *\n *  * @example\n * ```ts\n * if (isControlMessage(message)) {\n *   const msgChng: ChangeMessage = message // Err, type mismatch\n *   const msgCtrl: ControlMessage = message // Ok\n * }\n * ```\n */\nexport function isControlMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage {\n  return !isChangeMessage(message)\n}\n\nexport function isUpToDateMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage & { up_to_date: true } {\n  return isControlMessage(message) && message.headers.control === `up-to-date`\n}\n", "export class FetchError extends Error {\n  status: number\n  text?: string\n  json?: object\n  headers: Record<string, string>\n\n  constructor(\n    status: number,\n    text: string | undefined,\n    json: object | undefined,\n    headers: Record<string, string>,\n    public url: string,\n    message?: string\n  ) {\n    super(\n      message ||\n        `HTTP Error ${status} at ${url}: ${text ?? JSON.stringify(json)}`\n    )\n    this.name = `FetchError`\n    this.status = status\n    this.text = text\n    this.json = json\n    this.headers = headers\n  }\n\n  static async fromResponse(\n    response: Response,\n    url: string\n  ): Promise<FetchError> {\n    const status = response.status\n    const headers = Object.fromEntries([...response.headers.entries()])\n    let text: string | undefined = undefined\n    let json: object | undefined = undefined\n\n    const contentType = response.headers.get(`content-type`)\n    if (contentType && contentType.includes(`application/json`)) {\n      json = (await response.json()) as object\n    } else {\n      text = await response.text()\n    }\n\n    return new FetchError(status, text, json, headers, url)\n  }\n}\n\nexport class FetchBackoffAbortError extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`)\n  }\n}\n", "export const LIVE_CACHE_BUSTER_HEADER = `electric-cursor`\nexport const SHAPE_HANDLE_HEADER = `electric-handle`\nexport const CHUNK_LAST_OFFSET_HEADER = `electric-offset`\nexport const SHAPE_SCHEMA_HEADER = `electric-schema`\nexport const CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`\nexport const DATABASE_ID_QUERY_PARAM = `database_id`\nexport const COLUMNS_QUERY_PARAM = `columns`\nexport const LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`\nexport const SHAPE_HANDLE_QUERY_PARAM = `handle`\nexport const LIVE_QUERY_PARAM = `live`\nexport const OFFSET_QUERY_PARAM = `offset`\nexport const TABLE_QUERY_PARAM = `table`\nexport const WHERE_QUERY_PARAM = `where`\nexport const REPLICA_PARAM = `replica`\n", "import {\n  CHUNK_LAST_OFFSET_HEADER,\n  CHUNK_UP_TO_DATE_HEADER,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n} from './constants'\nimport { FetchError, FetchBackoffAbortError } from './error'\n\n// Some specific 4xx and 5xx HTTP status codes that we definitely\n// want to retry\nconst HTTP_RETRY_STATUS_CODES = [429]\n\nexport interface BackoffOptions {\n  /**\n   * Initial delay before retrying in milliseconds\n   */\n  initialDelay: number\n  /**\n   * Maximum retry delay in milliseconds\n   */\n  maxDelay: number\n  multiplier: number\n  onFailedAttempt?: () => void\n  debug?: boolean\n}\n\nexport const BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 10_000,\n  multiplier: 1.3,\n}\n\nexport function createFetchWithBackoff(\n  fetchClient: typeof fetch,\n  backoffOptions: BackoffOptions = BackoffDefaults\n): typeof fetch {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt,\n  } = backoffOptions\n  return async (...args: Parameters<typeof fetch>): Promise<Response> => {\n    const url = args[0]\n    const options = args[1]\n\n    let delay = initialDelay\n    let attempt = 0\n\n    /* eslint-disable no-constant-condition -- we re-fetch the shape log\n     * continuously until we get a non-ok response. For recoverable errors,\n     * we retry the fetch with exponential backoff. Users can pass in an\n     * AbortController to abort the fetching an any point.\n     * */\n    while (true) {\n      /* eslint-enable no-constant-condition */\n      try {\n        const result = await fetchClient(...args)\n        if (result.ok) return result\n        else throw await FetchError.fromResponse(result, url.toString())\n      } catch (e) {\n        onFailedAttempt?.()\n        if (options?.signal?.aborted) {\n          throw new FetchBackoffAbortError()\n        } else if (\n          e instanceof FetchError &&\n          !HTTP_RETRY_STATUS_CODES.includes(e.status) &&\n          e.status >= 400 &&\n          e.status < 500\n        ) {\n          // Any client errors cannot be backed off on, leave it to the caller to handle.\n          throw e\n        } else {\n          // Exponentially backoff on errors.\n          // Wait for the current delay duration\n          await new Promise((resolve) => setTimeout(resolve, delay))\n\n          // Increase the delay for the next attempt\n          delay = Math.min(delay * multiplier, maxDelay)\n\n          if (debug) {\n            attempt++\n            console.log(`Retry attempt #${attempt} after ${delay}ms`)\n          }\n        }\n      }\n    }\n  }\n}\n\ninterface ChunkPrefetchOptions {\n  maxChunksToPrefetch: number\n}\n\nconst ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2,\n}\n\n/**\n * Creates a fetch client that prefetches subsequent log chunks for\n * consumption by the shape stream without waiting for the chunk bodies\n * themselves to be loaded.\n *\n * @param fetchClient the client to wrap\n * @param prefetchOptions options to configure prefetching\n * @returns wrapped client with prefetch capabilities\n */\nexport function createFetchWithChunkBuffer(\n  fetchClient: typeof fetch,\n  prefetchOptions: ChunkPrefetchOptions = ChunkPrefetchDefaults\n): typeof fetch {\n  const { maxChunksToPrefetch } = prefetchOptions\n\n  let prefetchQueue: PrefetchQueue\n\n  const prefetchClient = async (...args: Parameters<typeof fetchClient>) => {\n    const url = args[0].toString()\n\n    // try to consume from the prefetch queue first, and if request is\n    // not present abort the prefetch queue as it must no longer be valid\n    const prefetchedRequest = prefetchQueue?.consume(...args)\n    if (prefetchedRequest) {\n      return prefetchedRequest\n    }\n\n    prefetchQueue?.abort()\n\n    // perform request and fire off prefetch queue if request is eligible\n    const response = await fetchClient(...args)\n    const nextUrl = getNextChunkUrl(url, response)\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1],\n      })\n    }\n\n    return response\n  }\n\n  return prefetchClient\n}\n\nclass PrefetchQueue {\n  readonly #fetchClient: typeof fetch\n  readonly #maxPrefetchedRequests: number\n  readonly #prefetchQueue = new Map<\n    string,\n    [Promise<Response>, AbortController]\n  >()\n  #queueHeadUrl: string | void\n  #queueTailUrl: string | void\n\n  constructor(options: {\n    url: Parameters<typeof fetch>[0]\n    requestInit: Parameters<typeof fetch>[1]\n    maxPrefetchedRequests: number\n    fetchClient?: typeof fetch\n  }) {\n    this.#fetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n    this.#maxPrefetchedRequests = options.maxPrefetchedRequests\n    this.#queueHeadUrl = options.url.toString()\n    this.#queueTailUrl = this.#queueHeadUrl\n    this.#prefetch(options.url, options.requestInit)\n  }\n\n  abort(): void {\n    this.#prefetchQueue.forEach(([_, aborter]) => aborter.abort())\n  }\n\n  consume(...args: Parameters<typeof fetch>): Promise<Response> | void {\n    const url = args[0].toString()\n\n    const request = this.#prefetchQueue.get(url)?.[0]\n    // only consume if request is in queue and is the queue \"head\"\n    // if request is in the queue but not the head, the queue is being\n    // consumed out of order and should be restarted\n    if (!request || url !== this.#queueHeadUrl) return\n    this.#prefetchQueue.delete(url)\n\n    // fire off new prefetch since request has been consumed\n    request\n      .then((response) => {\n        const nextUrl = getNextChunkUrl(url, response)\n        this.#queueHeadUrl = nextUrl\n        if (\n          this.#queueTailUrl &&\n          !this.#prefetchQueue.has(this.#queueTailUrl)\n        ) {\n          this.#prefetch(this.#queueTailUrl, args[1])\n        }\n      })\n      .catch(() => {})\n\n    return request\n  }\n\n  #prefetch(...args: Parameters<typeof fetch>): void {\n    const url = args[0].toString()\n\n    // only prefetch when queue is not full\n    if (this.#prefetchQueue.size >= this.#maxPrefetchedRequests) return\n\n    // initialize aborter per request, to avoid aborting consumed requests that\n    // are still streaming their bodies to the consumer\n    const aborter = new AbortController()\n\n    try {\n      const request = this.#fetchClient(url, {\n        ...(args[1] ?? {}),\n        signal: chainAborter(aborter, args[1]?.signal),\n      })\n      this.#prefetchQueue.set(url, [request, aborter])\n      request\n        .then((response) => {\n          // only keep prefetching if response chain is uninterrupted\n          if (!response.ok || aborter.signal.aborted) return\n\n          const nextUrl = getNextChunkUrl(url, response)\n\n          // only prefetch when there is a next URL\n          if (!nextUrl || nextUrl === url) {\n            this.#queueTailUrl = undefined\n            return\n          }\n\n          this.#queueTailUrl = nextUrl\n          return this.#prefetch(nextUrl, args[1])\n        })\n        .catch(() => {})\n    } catch (_) {\n      // ignore prefetch errors\n    }\n  }\n}\n\n/**\n * Generate the next chunk's URL if the url and response are valid\n */\nfunction getNextChunkUrl(url: string, res: Response): string | void {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER)\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER)\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER)\n\n  // only prefetch if shape handle and offset for next chunk are available, and\n  // response is not already up-to-date\n  if (!shapeHandle || !lastOffset || isUpToDate) return\n\n  const nextUrl = new URL(url)\n\n  // don't prefetch live requests, rushing them will only\n  // potentially miss more recent data\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return\n\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle)\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset)\n  return nextUrl.toString()\n}\n\n/**\n * Chains an abort controller on an optional source signal's\n * aborted state - if the source signal is aborted, the provided abort\n * controller will also abort\n */\nfunction chainAborter(\n  aborter: AbortController,\n  sourceSignal?: AbortSignal | null\n): AbortSignal {\n  if (!sourceSignal) return aborter.signal\n  if (sourceSignal.aborted) aborter.abort()\n  else\n    sourceSignal.addEventListener(`abort`, () => aborter.abort(), {\n      once: true,\n    })\n  return aborter.signal\n}\n", "import {\n  Message,\n  Offset,\n  Schema,\n  Row,\n  MaybePromise,\n  GetExtensions,\n} from './types'\nimport { MessageParser, Parser } from './parser'\nimport { isUpToDateMessage } from './helpers'\nimport { FetchError, FetchBackoffAbortError } from './error'\nimport {\n  BackoffDefaults,\n  BackoffOptions,\n  createFetchWithBackoff,\n  createFetchWithChunkBuffer,\n} from './fetch'\nimport {\n  CHUNK_LAST_OFFSET_HEADER,\n  LIVE_CACHE_BUSTER_HEADER,\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  COLUMNS_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n  SHAPE_SCHEMA_HEADER,\n  WHERE_QUERY_PARAM,\n  DATABASE_ID_QUERY_PARAM,\n  TABLE_QUERY_PARAM,\n  REPLICA_PARAM,\n} from './constants'\n\ntype Replica = `full` | `default`\n\n/**\n * Options for constructing a ShapeStream.\n */\nexport interface ShapeStreamOptions<T = never> {\n  /**\n   * The full URL to where the Shape is served. This can either be the Electric server\n   * directly or a proxy. E.g. for a local Electric instance, you might set `http://localhost:3000/v1/shape`\n   */\n  url: string\n\n  /**\n   * Which database to use.\n   * This is optional unless Electric is used with multiple databases.\n   */\n  databaseId?: string\n\n  /**\n   * The root table for the shape. Passed as a query parameter. Not required if you set the table in your proxy.\n   */\n  table?: string\n\n  /**\n   * The where clauses for the shape.\n   */\n  where?: string\n\n  /**\n   * The columns to include in the shape.\n   * Must include primary keys, and can only inlude valid columns.\n   */\n  columns?: string[]\n\n  /**\n   * If `replica` is `default` (the default) then Electric will only send the\n   * changed columns in an update.\n   *\n   * If it's `full` Electric will send the entire row with both changed and\n   * unchanged values.\n   *\n   * Setting `replica` to `full` will obviously result in higher bandwidth\n   * usage and so is not recommended.\n   */\n  replica?: Replica\n  /**\n   * The \"offset\" on the shape log. This is typically not set as the ShapeStream\n   * will handle this automatically. A common scenario where you might pass an offset\n   * is if you're maintaining a local cache of the log. If you've gone offline\n   * and are re-starting a ShapeStream to catch-up to the latest state of the Shape,\n   * you'd pass in the last offset and shapeHandle you'd seen from the Electric server\n   * so it knows at what point in the shape to catch you up from.\n   */\n  offset?: Offset\n  /**\n   * Similar to `offset`, this isn't typically used unless you're maintaining\n   * a cache of the shape log.\n   */\n  shapeHandle?: string\n  backoffOptions?: BackoffOptions\n\n  /**\n   * HTTP headers to attach to requests made by the client.\n   * Can be used for adding authentication headers.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Automatically fetch updates to the Shape. If you just want to sync the current\n   * shape and stop, pass false.\n   */\n  subscribe?: boolean\n  signal?: AbortSignal\n  fetchClient?: typeof fetch\n  parser?: Parser<T>\n}\n\nexport interface ShapeStreamInterface<T extends Row<unknown> = Row> {\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ): void\n  unsubscribeAllUpToDateSubscribers(): void\n  unsubscribeAll(): void\n  subscribeOnceToUpToDate(\n    callback: () => MaybePromise<void>,\n    error: (err: FetchError | Error) => void\n  ): () => void\n\n  isLoading(): boolean\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n\n  isUpToDate: boolean\n  shapeHandle?: string\n}\n\n/**\n * Reads updates to a shape from Electric using HTTP requests and long polling. Notifies subscribers\n * when new messages come in. Doesn't maintain any history of the\n * log but does keep track of the offset position and is the best way\n * to consume the HTTP `GET /v1/shape` api.\n *\n * @constructor\n * @param {ShapeStreamOptions} options - configure the shape stream\n * @example\n * Register a callback function to subscribe to the messages.\n * ```\n * const stream = new ShapeStream(options)\n * stream.subscribe(messages => {\n *   // messages is 1 or more row updates\n * })\n * ```\n *\n * To abort the stream, abort the `signal`\n * passed in via the `ShapeStreamOptions`.\n * ```\n * const aborter = new AbortController()\n * const issueStream = new ShapeStream({\n *   url: `${BASE_URL}/${table}`\n *   subscribe: true,\n *   signal: aborter.signal,\n * })\n * // Later...\n * aborter.abort()\n * ```\n */\n\nexport class ShapeStream<T extends Row<unknown> = Row>\n  implements ShapeStreamInterface<T>\n{\n  static readonly Replica = {\n    FULL: `full` as Replica,\n    DEFAULT: `default` as Replica,\n  }\n\n  readonly options: ShapeStreamOptions<GetExtensions<T>>\n\n  readonly #fetchClient: typeof fetch\n  readonly #messageParser: MessageParser<T>\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: Message<T>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n  readonly #upToDateSubscribers = new Map<\n    number,\n    [() => void, (error: FetchError | Error) => void]\n  >()\n\n  #lastOffset: Offset\n  #liveCacheBuster: string // Seconds since our Electric Epoch ðŸ˜Ž\n  #lastSyncedAt?: number // unix time\n  #isUpToDate: boolean = false\n  #connected: boolean = false\n  #shapeHandle?: string\n  #databaseId?: string\n  #schema?: Schema\n  #error?: unknown\n  #replica?: Replica\n\n  constructor(options: ShapeStreamOptions<GetExtensions<T>>) {\n    validateOptions(options)\n    this.options = { subscribe: true, ...options }\n    this.#lastOffset = this.options.offset ?? `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = this.options.shapeHandle\n    this.#databaseId = this.options.databaseId\n    this.#messageParser = new MessageParser<T>(options.parser)\n    this.#replica = this.options.replica\n\n    const baseFetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n\n    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, {\n      ...(options.backoffOptions ?? BackoffDefaults),\n      onFailedAttempt: () => {\n        this.#connected = false\n        options.backoffOptions?.onFailedAttempt?.()\n      },\n    })\n\n    this.#fetchClient = createFetchWithChunkBuffer(fetchWithBackoffClient)\n\n    this.start()\n  }\n\n  get shapeHandle() {\n    return this.#shapeHandle\n  }\n\n  get isUpToDate() {\n    return this.#isUpToDate\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  async start() {\n    this.#isUpToDate = false\n\n    const { url, table, where, columns, signal } = this.options\n\n    try {\n      while (\n        (!signal?.aborted && !this.#isUpToDate) ||\n        this.options.subscribe\n      ) {\n        const fetchUrl = new URL(url)\n        if (table) fetchUrl.searchParams.set(TABLE_QUERY_PARAM, table)\n        if (where) fetchUrl.searchParams.set(WHERE_QUERY_PARAM, where)\n        if (columns && columns.length > 0)\n          fetchUrl.searchParams.set(COLUMNS_QUERY_PARAM, columns.join(`,`))\n        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, this.#lastOffset)\n\n        if (this.#isUpToDate) {\n          fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`)\n          fetchUrl.searchParams.set(\n            LIVE_CACHE_BUSTER_QUERY_PARAM,\n            this.#liveCacheBuster\n          )\n        }\n\n        if (this.#shapeHandle) {\n          // This should probably be a header for better cache breaking?\n          fetchUrl.searchParams.set(\n            SHAPE_HANDLE_QUERY_PARAM,\n            this.#shapeHandle!\n          )\n        }\n\n        if (this.#databaseId) {\n          fetchUrl.searchParams.set(DATABASE_ID_QUERY_PARAM, this.#databaseId!)\n        }\n\n        if (\n          (this.#replica ?? ShapeStream.Replica.DEFAULT) !=\n          ShapeStream.Replica.DEFAULT\n        ) {\n          fetchUrl.searchParams.set(REPLICA_PARAM, this.#replica as string)\n        }\n\n        let response!: Response\n        try {\n          response = await this.#fetchClient(fetchUrl.toString(), {\n            signal,\n            headers: this.options.headers,\n          })\n          this.#connected = true\n        } catch (e) {\n          if (e instanceof FetchBackoffAbortError) break // interrupted\n          if (!(e instanceof FetchError)) throw e // should never happen\n          if (e.status == 409) {\n            // Upon receiving a 409, we should start from scratch\n            // with the newly provided shape handle\n            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER]\n            this.#reset(newShapeHandle)\n            await this.#publish(e.json as Message<T>[])\n            continue\n          } else if (e.status >= 400 && e.status < 500) {\n            // Notify subscribers\n            this.#sendErrorToUpToDateSubscribers(e)\n            this.#sendErrorToSubscribers(e)\n\n            // 400 errors are not actionable without additional user input,\n            // so we exit the loop\n            throw e\n          }\n        }\n\n        const { headers, status } = response\n        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER)\n        if (shapeHandle) {\n          this.#shapeHandle = shapeHandle\n        }\n\n        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER)\n        if (lastOffset) {\n          this.#lastOffset = lastOffset as Offset\n        }\n\n        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER)\n        if (liveCacheBuster) {\n          this.#liveCacheBuster = liveCacheBuster\n        }\n\n        const getSchema = (): Schema => {\n          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER)\n          return schemaHeader ? JSON.parse(schemaHeader) : {}\n        }\n        this.#schema = this.#schema ?? getSchema()\n\n        const messages = status === 204 ? `[]` : await response.text()\n\n        if (status === 204) {\n          // There's no content so we are live and up to date\n          this.#lastSyncedAt = Date.now()\n        }\n\n        const batch = this.#messageParser.parse(messages, this.#schema)\n\n        // Update isUpToDate\n        if (batch.length > 0) {\n          const prevUpToDate = this.#isUpToDate\n          const lastMessage = batch[batch.length - 1]\n          if (isUpToDateMessage(lastMessage)) {\n            this.#lastSyncedAt = Date.now()\n            this.#isUpToDate = true\n          }\n\n          await this.#publish(batch)\n          if (!prevUpToDate && this.#isUpToDate) {\n            this.#notifyUpToDateSubscribers()\n          }\n        }\n      }\n    } catch (err) {\n      this.#error = err\n    } finally {\n      this.#connected = false\n    }\n  }\n\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  subscribeOnceToUpToDate(\n    callback: () => MaybePromise<void>,\n    error: (err: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#upToDateSubscribers.set(subscriptionId, [callback, error])\n\n    return () => {\n      this.#upToDateSubscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAllUpToDateSubscribers(): void {\n    this.#upToDateSubscribers.clear()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#lastSyncedAt\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    if (this.#lastSyncedAt === undefined) return Infinity\n    return Date.now() - this.#lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#connected\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading(): boolean {\n    return !this.isUpToDate\n  }\n\n  async #publish(messages: Message<T>[]): Promise<void> {\n    await Promise.all(\n      Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n        try {\n          await callback(messages)\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n    )\n  }\n\n  #sendErrorToSubscribers(error: Error) {\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  #notifyUpToDateSubscribers() {\n    this.#upToDateSubscribers.forEach(([callback]) => {\n      callback()\n    })\n  }\n\n  #sendErrorToUpToDateSubscribers(error: FetchError | Error) {\n    this.#upToDateSubscribers.forEach(([_, errorCallback]) =>\n      errorCallback(error)\n    )\n  }\n\n  /**\n   * Resets the state of the stream, optionally with a provided\n   * shape handle\n   */\n  #reset(shapeHandle?: string) {\n    this.#lastOffset = `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = shapeHandle\n    this.#isUpToDate = false\n    this.#connected = false\n    this.#schema = undefined\n  }\n}\n\nfunction validateOptions<T>(options: Partial<ShapeStreamOptions<T>>): void {\n  if (!options.url) {\n    throw new Error(`Invalid shape options. It must provide the url`)\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new Error(\n      `Invalid signal option. It must be an instance of AbortSignal.`\n    )\n  }\n\n  if (\n    options.offset !== undefined &&\n    options.offset !== `-1` &&\n    !options.shapeHandle\n  ) {\n    throw new Error(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    )\n  }\n  return\n}\n", "import { Message, Row } from './types'\nimport { isChangeMessage, isControlMessage } from './helpers'\nimport { FetchError } from './error'\nimport { ShapeStreamInterface } from './client'\n\nexport type ShapeData<T extends Row<unknown> = Row> = Map<string, T>\nexport type ShapeChangedCallback<T extends Row<unknown> = Row> = (data: {\n  value: ShapeData<T>\n  rows: T[]\n}) => void\n\n/**\n * A Shape is an object that subscribes to a shape log,\n * keeps a materialised shape `.rows` in memory and\n * notifies subscribers when the value has changed.\n *\n * It can be used without a framework and as a primitive\n * to simplify developing framework hooks.\n *\n * @constructor\n * @param {ShapeStream<T extends Row>} - the underlying shape stream\n * @example\n * ```\n * const shapeStream = new ShapeStream<{ foo: number }>(url: `http://localhost:3000/v1/shape`, table: `foo`})\n * const shape = new Shape(shapeStream)\n * ```\n *\n * `rows` returns a promise that resolves the Shape data once the Shape has been\n * fully loaded (and when resuming from being offline):\n *\n *     const rows = await shape.rows\n *\n * `currentRows` returns the current data synchronously:\n *\n *     const rows = shape.currentRows\n *\n *  Subscribe to updates. Called whenever the shape updates in Postgres.\n *\n *     shape.subscribe(({ rows }) => {\n *       console.log(rows)\n *     })\n */\nexport class Shape<T extends Row<unknown> = Row> {\n  readonly #stream: ShapeStreamInterface<T>\n\n  readonly #data: ShapeData<T> = new Map()\n  readonly #subscribers = new Map<number, ShapeChangedCallback<T>>()\n\n  #hasNotifiedSubscribersUpToDate: boolean = false\n  #error: FetchError | false = false\n\n  constructor(stream: ShapeStreamInterface<T>) {\n    this.#stream = stream\n    this.#stream.subscribe(\n      this.#process.bind(this),\n      this.#handleError.bind(this)\n    )\n    const unsubscribe = this.#stream.subscribeOnceToUpToDate(\n      () => {\n        unsubscribe()\n      },\n      (e) => {\n        this.#handleError(e)\n        throw e\n      }\n    )\n  }\n\n  get isUpToDate(): boolean {\n    return this.#stream.isUpToDate\n  }\n\n  get rows(): Promise<T[]> {\n    return this.value.then((v) => Array.from(v.values()))\n  }\n\n  get currentRows(): T[] {\n    return Array.from(this.currentValue.values())\n  }\n\n  get value(): Promise<ShapeData<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.#stream.isUpToDate) {\n        resolve(this.currentValue)\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe()\n          if (this.#error) reject(this.#error)\n          resolve(value)\n        })\n      }\n    })\n  }\n\n  get currentValue() {\n    return this.#data\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#stream.lastSyncedAt()\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.#stream.lastSynced()\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.#stream.isLoading()\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#stream.isConnected()\n  }\n\n  subscribe(callback: ShapeChangedCallback<T>): () => void {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, callback)\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  get numSubscribers() {\n    return this.#subscribers.size\n  }\n\n  #process(messages: Message<T>[]): void {\n    let dataMayHaveChanged = false\n    let isUpToDate = false\n    let newlyUpToDate = false\n\n    messages.forEach((message) => {\n      if (isChangeMessage(message)) {\n        dataMayHaveChanged = [`insert`, `update`, `delete`].includes(\n          message.headers.operation\n        )\n\n        switch (message.headers.operation) {\n          case `insert`:\n            this.#data.set(message.key, message.value)\n            break\n          case `update`:\n            this.#data.set(message.key, {\n              ...this.#data.get(message.key)!,\n              ...message.value,\n            })\n            break\n          case `delete`:\n            this.#data.delete(message.key)\n            break\n        }\n      }\n\n      if (isControlMessage(message)) {\n        switch (message.headers.control) {\n          case `up-to-date`:\n            isUpToDate = true\n            if (!this.#hasNotifiedSubscribersUpToDate) {\n              newlyUpToDate = true\n            }\n            break\n          case `must-refetch`:\n            this.#data.clear()\n            this.#error = false\n            this.#hasNotifiedSubscribersUpToDate = false\n            isUpToDate = false\n            newlyUpToDate = false\n            break\n        }\n      }\n    })\n\n    // Always notify subscribers when the Shape first is up to date.\n    // FIXME this would be cleaner with a simple state machine.\n    if (newlyUpToDate || (isUpToDate && dataMayHaveChanged)) {\n      this.#hasNotifiedSubscribersUpToDate = true\n      this.#notify()\n    }\n  }\n\n  #handleError(e: Error): void {\n    if (e instanceof FetchError) {\n      this.#error = e\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    this.#subscribers.forEach((callback) => {\n      callback({ value: this.currentValue, rows: this.currentRows })\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["key", "value", "_fetchClient", "_ShapeStream", "_a", "_b", "_subscribers", "_error"]
}
